#!/usr/bin/env python3
"""
Test de filtros C++ para cppcheck.
Ejecutar desde la ra√≠z del proyecto: python test_cpp_filter.py
"""

import sys
import os

# A√±adir el directorio src al path para importar sast_orchestrator
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from core.sast_orchestrator import SASTOrchestrator

def test_cpp_filters():
    """Test de filtros de C++ mejorados"""
    
    print("üß™ TEST DE FILTROS C++ MEJORADOS")
    print("=" * 60)
    
    # Crear instancia del orquestador (sin configuraci√≥n espec√≠fica)
    orchestrator = SASTOrchestrator()
    
    test_cases = [
        # ========== DEBE SER FILTRADO (falso positivo) ==========
        {
            'name': '1. Invalid C code en archivo C++',
            'rule_id': 'invalidCode',
            'message': 'invalid C code: namespace protobuf {',
            'file': '/src/protobuf/message.pb.cc',
            'severity': 'CRITICAL',
            'should_keep': False
        },
        {
            'name': '2. Invalid C code con class',
            'rule_id': 'invalidCode', 
            'message': 'invalid C code: class Processor {',
            'file': '/src/processor.cpp',
            'severity': 'HIGH',
            'should_keep': False
        },
        {
            'name': '3. Archivo protobuf (.pb.cc)',
            'rule_id': 'unusedFunction',
            'message': 'Unused function: process_message',
            'file': '/generated/messages.pb.cc',
            'severity': 'MEDIUM',
            'should_keep': False
        },
        {
            'name': '4. Archivo protobuf header (.pb.h)',
            'rule_id': 'missingIncludeSystem',
            'message': 'Include file: <string.h> not found',
            'file': '/generated/header.pb.h',
            'severity': 'INFO',
            'should_keep': False
        },
        {
            'name': '5. Error de versi√≥n de protoc',
            'rule_id': 'syntaxError',
            'message': '#error This file was generated by a newer version of protoc',
            'file': '/src/protobuf/compiled.pb.cc',
            'severity': 'CRITICAL',
            'should_keep': False
        },
        # ========== DEBE PASAR (verdadero positivo) ==========
        {
            'name': '6. Buffer overflow real',
            'rule_id': 'bufferOverflow',
            'message': 'Buffer overflow in function process_data',
            'file': '/src/buffer.c',
            'severity': 'CRITICAL',
            'should_keep': True
        },
        {
            'name': '7. Memory leak',
            'rule_id': 'memleak',
            'message': 'Memory leak: allocated memory not freed',
            'file': '/src/memory.c',
            'severity': 'HIGH',
            'should_keep': True
        },
        {
            'name': '8. Format string vulnerability',
            'rule_id': 'formatString',
            'message': 'Unsafe format string in printf',
            'file': '/src/format.c',
            'severity': 'MEDIUM',
            'should_keep': True
        },
        {
            'name': '9. Use after free',
            'rule_id': 'useAfterFree',
            'message': 'Use after free: pointer used after deletion',
            'file': '/src/pointer.cpp',
            'severity': 'CRITICAL',
            'should_keep': True
        },
        {
            'name': '10. Info sin keyword de seguridad',
            'rule_id': 'styleWarning',
            'message': 'Variable shadowing',
            'file': '/src/utils.c',
            'severity': 'INFO',
            'should_keep': False  # INFO sin keyword de seguridad debe filtrarse
        },
        {
            'name': '11. Info CON keyword de seguridad',
            'rule_id': 'bufferAccess',
            'message': 'Buffer access out of bounds',
            'file': '/src/array.c',
            'severity': 'INFO',
            'should_keep': True  # Aunque sea INFO, tiene keyword de seguridad
        }
    ]
    
    passed = 0
    failed = 0
    
    for test in test_cases:
        print(f"\nüîç {test['name']}")
        print(f"   Archivo: {test['file']}")
        print(f"   Mensaje: {test['message'][:60]}...")
        print(f"   Severidad: {test['severity']}")
        
        # Llamar al filtro
        result = orchestrator._filter_cppcheck_issue(test)
        
        # Verificar resultado
        expected = test['should_keep']
        
        if result == expected:
            print(f"   ‚úÖ PAS√ì: Esperado {expected}, Obtenido {result}")
            passed += 1
        else:
            print(f"   ‚ùå FALL√ì: Esperado {expected}, Obtenido {result}")
            failed += 1
    
    print("\n" + "=" * 60)
    print("üìä RESULTADOS FINALES:")
    print(f"   ‚úÖ Pasados: {passed}")
    print(f"   ‚ùå Fallados: {failed}")
    print(f"   üìà Tasa de acierto: {passed/(passed+failed)*100:.1f}%")
    print("=" * 60)
    
    if failed == 0:
        print("üéâ ¬°Todos los tests pasaron!")
    else:
        print("‚ö†Ô∏è  Algunos tests fallaron. Revisa la implementaci√≥n.")
    
    return failed == 0

if __name__ == "__main__":
    # Ejecutar tests
    success = test_cpp_filters()
    
    # Salir con c√≥digo apropiado
    sys.exit(0 if success else 1)