# üîÑ Prompt de Continuidad Actualizado

## üìà **Estado Actual**

‚úÖ **An√°lisis SAST b√°sico operativo** con m√∫ltiples herramientas (Bandit, Safety, Cppcheck, Flawfinder, Semgrep)  
‚úÖ **Soporte para an√°lisis local y remoto** (GitHub repos)  
‚úÖ **Generaci√≥n de reportes** en JSON, TXT y HTML  
‚úÖ **Filtrado b√°sico de severidad** (critical-only)  
‚ö†Ô∏è **Problemas de precisi√≥n** en C++ (falsos positivos por namespace/class/protobuf)  
üöß **Pr√≥xima fase**: Pipeline multi-LLM con worktrees

## üéØ **Objetivos para la Pr√≥xima Sesi√≥n**

### **FASE 1: SAST Mejorado** (D√≠a 1)
**Meta**: Reducir falsos positivos y enriquecer contexto para LLMs

#### **Tareas Prioritarias**:

1. **Filtrado Inteligente de C++** (`sast_runner.py`, ~l√≠nea 250)
   ```python
   def filter_cppcheck_false_positives(issue):
       """Filtra falsos positivos espec√≠ficos de C/C++"""
       msg = issue.get("message", "").lower()
       file_path = issue.get("file", "")
       
       # 1. Ignorar 'invalid C code' en archivos C++
       if "invalid c code" in msg:
           ext = os.path.splitext(file_path)[1].lower()
           if ext in ['.cc', '.cpp', '.cxx', '.hpp']:
               return False
           
           # Tambi√©n si contiene palabras clave de C++
           if any(keyword in issue.get("message", "") 
                  for keyword in ["namespace", "class", "protobuf"]):
               return False
       
       # 2. Excluir archivos generados por protobuf
       if any(pattern in file_path for pattern in ['.pb.', '_generated', '_pb2']):
           return False
       
       # 3. Excluir errores de versi√≥n de protoc
       if "#error this file was generated by" in msg:
           return False
       
       return True
   ```

2. **Enriquecimiento de Contexto por Vulnerabilidad**
   - Extraer funci√≥n, variables y √°mbito del c√≥digo
   - Identificar CWE y categor√≠a MITRE ATT&CK
   - Proporcionar ejemplos de remediaci√≥n
   - Encontrar archivos relacionados y casos de prueba

3. **Configuraci√≥n de Filtros Personalizables**
   ```yaml
   # config/sast_filters.yaml
   cppcheck:
     exclude_patterns:
       - "*.pb.cc"
       - "*.pb.h"
       - "*_generated.*"
     exclude_messages:
       - "invalid C code"
       - "#error This file was generated"
     language_detection:
       c_extensions: [".c", ".h"]
       cpp_extensions: [".cc", ".cpp", ".cxx", ".hpp"]
   ```

#### **Puntos de Partida**:
- **Archivo principal**: `sast_runner.py` (m√©todos de procesamiento)
- **Test cases**: 
  - `test_vuln.c` (vulnerabilidad real ‚Üí debe detectarse)
  - `test_cpp.c` (falsos positivos ‚Üí deben filtrarse)
- **Repo de validaci√≥n**: `alonsoir/test-zeromq-c-`

#### **M√©trica de √âxito**:
- ‚úÖ **Reducir falsos positivos** cr√≠ticos de 13 a ‚â§5 en repositorios C++
- ‚úÖ **Mantener verdaderos positivos** (buffer overflows reales)
- ‚úÖ **Generar contexto enriquecido** para cada vulnerabilidad

### **FASE 2: Worktrees Multi-LLM** (D√≠a 2)
**Meta**: Implementar arquitectura aislada para m√∫ltiples LLMs

#### **Esquema de Implementaci√≥n**:
```python
class GitWorktreeManager:
    """Clone √∫nico + worktrees aislados por LLM"""
    # 1. Setup main repository (clone √∫nico)
    # 2. Create worktree per LLM/issue
    # 3. Prepare context with enriched SAST analysis
    # 4. Apply LLM fixes with proper attribution
    # 5. Push branches and optionally create PRs
```

### **FASE 3: M√°quina de Estados LLM** (D√≠a 3)
**Meta**: Orquestar comunicaci√≥n as√≠ncrona con m√∫ltiples proveedores de LLM

## üöÄ **Comandos de Validaci√≥n**

```bash
# 1. Validar mejora de SAST (reducci√≥n falsos positivos)
python tdh_unified.py analyze alonsoir/test-zeromq-c- --sast --critical-only

# 2. Generar reporte enriquecido para LLMs
python tdh_unified.py analyze . --sast --critical-only --format json --output sast_context.json

# 3. Test con c√≥digo vulnerable real (debe mantener detecciones)
python tdh_unified.py analyze . --sast --critical-only --max-issues 5
```

## üìä **Criterios de Aceptaci√≥n**

### **Para Ma√±ana (Fin de Fase 1)**:
- [ ] Cppcheck no reporta `namespace`/`class` como "invalid C code"
- [ ] Archivos `.pb.cc`/`.pb.h` excluidos del an√°lisis
- [ ] Buffer overflows reales siguen detect√°ndose
- [ ] Reporte JSON incluye contexto enriquecido (funci√≥n, variables, remediaciones)

### **Para la Pr√≥xima Semana**:
- [ ] Sistema de worktrees funcionando para 3 LLMs
- [ ] Cada LLM puede trabajar en ramas aisladas
- [ ] Commits con autor√≠a apropiada por LLM
- [ ] Pipeline end-to-end: SAST ‚Üí Contexto ‚Üí LLM Fix ‚Üí PR

## üîß **Debug Tips**

1. **Para probar filtros C++**:
   ```python
   # Debug en sast_runner.py
   print(f"File: {issue['file']}, Message: {issue['message'][:100]}")
   print(f"Should filter: {should_filter}")
   ```

2. **Ver resultados sin filtros**:
   ```bash
   python tdh_unified.py analyze . --sast --no-filter-noise
   ```

3. **Check archivos procesados**:
   ```bash
   find . -name "*.cpp" -o -name "*.cc" | head -10
   ```

## üéØ **Plan de Acci√≥n Ma√±ana**

1. **9:00-10:30** - Implementar filtros C++ en `sast_runner.py`
2. **10:30-11:30** - Test con `test_cpp.c` y `test_vuln.c`
3. **11:30-12:30** - Validar con repo `alonsoir/test-zeromq-c-`
4. **12:30-13:30** - Implementar enriquecimiento de contexto
5. **14:00-15:00** - Documentar cambios y actualizar configs
6. **15:00-16:00** - Preparar base para Fase 2 (worktrees)

---

**¬øListos para empezar ma√±ana con los filtros C++?** ¬°Recordemos que un buen an√°lisis SAST es la base para que los LLMs generen fixes de calidad! üîçüöÄ